#include <iostream>                 
// Подключаем стандартную библиотеку ввода и вывода,
// чтобы использовать std::cout для печати результатов на экран.

#include <vector>                   
// Подключаем библиотеку контейнеров, чтобы использовать std::vector
// для удобного хранения динамического массива.

#include <random>                   
// Подключаем библиотеку генерации случайных чисел,
// которая обеспечивает корректную и качественную псевдослучайность.

#include <chrono>                   
// Подключаем библиотеку для точного измерения времени выполнения программы.

#include <omp.h>                    
// Подключаем заголовочный файл OpenMP, который позволяет использовать
// директивы параллельных вычислений.

int main() {                        
// Основная функция программы — точка входа.

    const int N = 10000;           
    // Задаём размер массива: 10 000 элементов.

    std::vector<int> arr(N);       
    // Создаём динамический массив из 10 000 целых чисел.

    std::mt19937 gen(std::random_device{}());          
    // Создаём генератор псевдослучайных чисел на основе алгоритма Mersenne Twister.
    // Инициализируем его случайным значением, полученным от операционной системы.

    std::uniform_int_distribution<> dist(1, 100000);  
    // Задаём распределение, которое будет генерировать числа
    // равномерно в диапазоне от 1 до 100 000.

    for (int i = 0; i < N; ++i)    
    // Цикл, который проходит по каждому элементу массива.

        arr[i] = dist(gen);        
        // Для каждой позиции массива генерируем случайное число
        // и записываем его в соответствующую ячейку.

    auto start1 = std::chrono::high_resolution_clock::now(); 
    // Фиксируем момент начала работы последовательного алгоритма.

    int min1 = arr[0];             
    // Инициализируем переменную минимума первым элементом массива.

    int max1 = arr[0];             
    // Инициализируем переменную максимума первым элементом массива.

    for (int i = 1; i < N; ++i) {  
    // Последовательно перебираем массив начиная со второго элемента.

        if (arr[i] < min1)         
            min1 = arr[i];        
            // Если текущий элемент меньше текущего минимума,
            // обновляем значение минимума.

        if (arr[i] > max1)         
            max1 = arr[i];        
            // Если текущий элемент больше текущего максимума,
            // обновляем значение максимума.
    }

    auto end1 = std::chrono::high_resolution_clock::now();   
    // Фиксируем момент окончания последовательных вычислений.

    double time1 = std::chrono::duration<double>(end1 - start1).count(); 
    // Вычисляем продолжительность работы последовательного алгоритма в секундах.

    auto start2 = std::chrono::high_resolution_clock::now(); 
    // Фиксируем момент начала параллельной версии алгоритма.

    int min2 = arr[0];             
    // Инициализируем общий минимум для параллельной версии.

    int max2 = arr[0];             
    // Инициализируем общий максимум для параллельной версии.

    #pragma omp parallel for reduction(min:min2) reduction(max:max2) 
    // Эта директива сообщает компилятору:
    // 1) Разделить цикл между несколькими потоками.
    // 2) Для каждого потока создать собственные копии min2 и max2.
    // 3) После завершения всех потоков объединить результаты,
    //    выбрав глобальный минимум и максимум.

    for (int i = 0; i < N; ++i) {  
    // Цикл, который выполняется параллельно несколькими потоками.

        if (arr[i] < min2)         
            min2 = arr[i];        
            // Каждый поток обновляет свою локальную копию минимума.

        if (arr[i] > max2)         
            max2 = arr[i];        
            // Каждый поток обновляет свою локальную копию максимума.
    }

    auto end2 = std::chrono::high_resolution_clock::now();   
    // Фиксируем момент завершения параллельных вычислений.

    double time2 = std::chrono::duration<double>(end2 - start2).count(); 
    // Вычисляем продолжительность параллельного алгоритма.

    std::cout << "Seq version:\n";   
    // Выводим заголовок.

    std::cout << "Min = " << min1 << ", Max = " << max1 << "\n"; 
    // Выводим найденные значения минимума и максимума для последовательной версии.

    std::cout << "Time: " << time1 << " seconds\n\n"; 
    // Выводим время выполнения последовательной версии.

    std::cout << "Parallel version (OpenMP):\n"; 
    // Выводим заголовок.

    std::cout << "Min = " << min2 << ", Max = " << max2 << "\n"; 
    // Выводим найденные значения минимума и максимума для параллельной версии.

    std::cout << "Time: " << time2 << " seconds\n"; 
    // Выводим время выполнения параллельной версии.

    return 0;                       
    // Корректно завершаем работу программы.
}
