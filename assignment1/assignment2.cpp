#include <iostream>      // потоковый вывод
#include <vector>        // контейнер vector
#include <random>        // генератор случайных чисел
#include <chrono>        // работа с временем


int main() {
    const size_t N = 1'000'000;
//в стековом кадре создаётся локальная переменная
//записано значение 1 000 000.
    std::vector<int> arr(N);
//в стеке создаётся объект vector arr
//vector хранит: размер, ёмкость, указатель на память в куче
//конструктор vector запрашивает из кучи N × sizeof(int) = 4 000 000 байт
//выделяется непрерывный блок в куче
//pointer в arr → на адрес начала блока
//автоматически инициализируются все элементы (0).
    std::mt19937 gen(std::random_device{}());

//в стеке создаётся объект gen
//mt19937 содержит внутреннее состояние генератора (~2.5 KB)
//random_device генерирует seed, которым инициализируется состояние.
    std::uniform_int_distribution<int> dist(-1000000, 1000000);
// в стеке создаётся объект распределения
//сохраняются параметры min/max границ.
    for (size_t i = 0; i < N; ++i) {
        arr[i] = dist(gen);
    }
//создаётся переменная i в регистре или стеке (зависит от оптимизаций)
//ычисляется адрес arr + i (арифметика указателей по 4 байта)
//вызывается dist(gen): распределение получает следующее случайное число
//число записывается в кучу в arr[i]
    auto start = std::chrono::high_resolution_clock::now();
//создаётся точка времени start
//вызывает системный вызов получения timestamp
//значение хранится в регистре/стеке.
    int mn = arr[0];
    int mx = arr[0];
//создаются два объекта int в стековом кадре
//читаются два первых числа из кучи (arr[0])
//копируются в mn, mx.
    for (size_t i = 1; i < N; ++i) {
        if (arr[i] < mn) mn = arr[i];
        if (arr[i] > mx) mx = arr[i];
    }
//На каждой итерации:
//вычисляется адрес arr + i
//загружается int из кучи
//CPU сравнивает с mn → условный переход
//CPU сравнивает с mx → условный переход
//возможны branch mispredicts (зависит от распределения данных)
//вычисления выполняются строго последовательно
//асимптотика O(N).
    auto end = std::chrono::high_resolution_clock::now();
//фиксируется вторая временная метка.
    auto duration =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
//вычисляется разница двух timestamp
//перевод в миллисекунды
//duration хранится как целое число.
    std::cout << "min = " << mn << "\n";
    std::cout << "max = " << mx << "\n";
    std::cout << "time = " << duration << " ms\n";
//потоковый вывод вызывает системные функции для записи в stdout.
    return 0;
}
//стековый кадр main уничтожается
//vector arr вызывается деструктор
//деструктор освобождает блок памяти в куче
//освобождаются локальные объекты, включая генератор
//процесс завершается, ОС снимает резервации.