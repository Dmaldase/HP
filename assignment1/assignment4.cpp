// Библиотека стандартного ввода-вывода
#include <iostream>

// Библиотека динамического массива std::vector
#include <vector>

// Библиотека генераторов случайных чисел (mt19937, distribution)
#include <random>

// Библиотека высокоточных таймеров
#include <chrono>

// Библиотека OpenMP для параллельных вычислений
#include <omp.h>

// Точка входа в программу
int main() {

    // Константа — количество элементов в массиве
    const size_t N = 5'000'000;

    // Создание динамического массива из N целых чисел
    // Память выделяется в куче, объект vector хранится в стеке
    std::vector<int> arr(N);

    // ----------------- ЗАПОЛНЕНИЕ МАССИВА -----------------

    // Создание генератора псевдослучайных чисел Mersenne Twister
    std::mt19937 gen(std::random_device{}());

    // Задание диапазона значений: от 1 до 100
    std::uniform_int_distribution<int> dist(1, 100);

    // Последовательное заполнение массива случайными значениями
    for (size_t i = 0; i < N; ++i) {

        // Генерация случайного числа и запись его в массив
        arr[i] = dist(gen);
    }

    // ----------------- ПОСЛЕДОВАТЕЛЬНЫЙ РАСЧЁТ -----------------

    // Фиксация времени начала последовательных вычислений
    auto t1 = std::chrono::high_resolution_clock::now();

    // Переменная для накопления суммы (64-битная)
    long long sum_seq = 0;

    // Последовательный проход по массиву
    for (size_t i = 0; i < N; ++i) {

        // Прибавление текущего элемента массива к сумме
        sum_seq += arr[i];
    }

    // Вычисление среднего арифметического
    double avg_seq = static_cast<double>(sum_seq) / N;

    // Фиксация времени окончания последовательных вычислений
    auto t2 = std::chrono::high_resolution_clock::now();

    // Вычисление продолжительности последовательного участка в микросекундах
    auto dt_seq =
        std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();

    // ----------------- ПАРАЛЛЕЛЬНЫЙ РАСЧЁТ -----------------

    // Фиксация времени начала параллельных вычислений
    auto t3 = std::chrono::high_resolution_clock::now();

    // Переменная для накопления суммы в параллельной версии
    long long sum_par = 0;

    // Параллельный цикл с автоматическим разбиением итераций по потокам
    // reduction(+:sum_par) гарантирует корректное сложение результатов всех потоков
    #pragma omp parallel for reduction(+:sum_par)
    for (size_t i = 0; i < N; ++i) {

        // Каждый поток прибавляет свой участок массива
        sum_par += arr[i];
    }

    // Вычисление среднего арифметического в параллельной версии
    double avg_par = static_cast<double>(sum_par) / N;

    // Фиксация времени окончания параллельных вычислений
    auto t4 = std::chrono::high_resolution_clock::now();

    // Вычисление продолжительности параллельного участка в микросекундах
    auto dt_par =
        std::chrono::duration_cast<std::chrono::microseconds>(t4 - t3).count();

    // ----------------- ВЫВОД РЕЗУЛЬТАТОВ -----------------

    // Вывод среднего значения, вычисленного последовательно
    std::cout << "Sequential average = " << avg_seq << "\n";

    // Вывод среднего значения, вычисленного параллельно
    std::cout << "Parallel average   = " << avg_par << "\n";

    // Вывод времени последовательных вычислений
    std::cout << "Sequential time = " << dt_seq << " us\n";

    // Вывод времени параллельных вычислений
    std::cout << "Parallel time   = " << dt_par << " us\n";

    // Корректное завершение программы
    return 0;
}