#include <iostream>                // потоковый вывод в stdout
#include <vector>                  // динамический массив в куче
#include <random>                  // генератор случайных чисел и распределение
#include <chrono>                  // высокоточное измерение времени
#include <omp.h>                   // директивы OpenMP для параллельного исполнения

int main() {
    // ОС создала процесс, стек потока и вызвала main
    const size_t N = 1'000'000;
    // в стековом кадре main выделяется память под локальную переменную N (8 байт)

    std::vector<int> arr(N);
    // создается объект std::vector в стеке (размер/емкость/указатель)
    // vector запрашивает из кучи N * sizeof(int) = 4 000 000 байт
    // выделяется непрерывный блок памяти, указатель сохраняется внутри arr

    std::mt19937 gen(std::random_device{}());
    // создаётся объект генератора в стековом кадре
    // random_device возвращает seed, им инициализируется состояние генератора
    // mt19937 содержит внутреннее состояние ~2.5 KB (не на стеке, а в объекте в сегменте данных стека)

    std::uniform_int_distribution<int> dist(-1000000,1000000);
    // объект распределения хранит границы и алгоритм выбора случайного числа

    for(size_t i=0;i<N;++i)
        arr[i] = dist(gen);
        // для каждой итерации:
        // выделяется переменная i (в регистре или стеке)
        // вычисляется адрес arr + i
        // вызывается dist(gen)
        // генерируется число и записывается в элемент массива в куче

    auto t1 = std::chrono::high_resolution_clock::now();
    // фиксируется timestamp — вызов системных часов
    // создаётся объект времени start в стеке

    int mn = arr[0];
    int mx = arr[0];
    // в стековом кадре создаются две переменные mn и mx (по 4 байта)
    // выполняется чтение arr[0] из кучи и копирование в регистр/стек

    #pragma omp parallel for reduction(min:mn) reduction(max:mx)
    // при входе в параллельную секцию OpenMP:
    // создаёт пул потоков (обычно равный числу ядер)
    // каждый поток получает диапазон итераций цикла
    // mn и mx становятся переменными reduction:
    //  — для каждого потока создаются приватные копии mn_local и mx_local
    //  — инициализированные значениями mn и mx
    // таким образом нет гонок из-за записи по тем же адресам

    for(size_t i=1;i<N;i++){
        // каждый поток выполняет свой диапазон индексов i
        if(arr[i] < mn) mn = arr[i];
        // arr[i] читается из кучи
        // сравнение arr[i] с приватным mn_local
        // если меньше — присваивание в локальную копию mn

        if(arr[i] > mx) mx = arr[i];
        // аналогично сравнение и возможное присваивание mx_local
    }
    // после завершения цикла OpenMP выполняет фазу reduction:
    // из локальных mn_local всех потоков выбирается глобальный минимум
    // из локальных mx_local всех потоков — глобальный максимум
    // результаты записываются в mn и mx в основной нити

    auto t2 = std::chrono::high_resolution_clock::now();
    // берется вторая временная метка

    auto dt = std::chrono::duration_cast<std::chrono::microseconds>(t2-t1).count();
    // вычисляется разница end-start
    // преобразуется в микросекунды
    // результат dt хранится как целое в стеке

    std::cout << "min = " << mn << "\n";
    std::cout << "max = " << mx << "\n";
    std::cout << "parallel time = " << dt << " us\n";
    // потоковый вывод вызывает операции записи в stdout

    return 0;
    // стековый кадр main уничтожается
    // вызывается деструктор vector и освобождает память в куче
    // runtime завершает процесс, ОС освобождает ресурсы
}