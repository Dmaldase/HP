#include <iostream>   // подключение стандартной библиотеки потокового ввода/вывода
                      // определяет std::cout/std::cin/std::endl и механизм буферизации stdout

#include <chrono>     // предоставляет типы для высокоточного измерения времени:
                      // high_resolution_clock, duration_cast, nanoseconds, milliseconds

#include <random>     // предоставляет генераторы случайных чисел и распределения,
                      // включая std::mt19937 и uniform_int_distribution

#include <omp.h>      // заголовок OpenMP, определяет директивы, API функций omp_*

//-------------------------------------------------------------
// Последовательное вычисление среднего значения
//-------------------------------------------------------------

double sequential_avg(int* arr, size_t N) {

    // sum хранится в стековом кадре функции sequential_avg
    // long long выбран, чтобы избежать переполнения 32-bit int при суммировании ~5 млн элементов
    long long sum = 0;

    // цикл линейно читает элементы массива
    // — arr[i] находится в куче (динамическое выделение в main)
    // — i хранится в регистре CPU или на стеке, зависит от реализации
    for (size_t i = 0; i < N; i++) {
        sum += arr[i];
        // CPU выполняет загрузку arr[i] по адресу:
        //   base address arr + i*sizeof(int)
        // последовательная версия использует один поток ⇒ нет гонок
    }

    // приведение типа sum выполняется в double
    // операция деления будет выполнена в FPU/SIMD регистре
    return static_cast<double>(sum) / N;
}

//-------------------------------------------------------------
// Параллельное вычисление среднего значения OpenMP reduction
//-------------------------------------------------------------

double parallel_avg(int* arr, size_t N) {

    // переменная sum объявлена как shared, но reduction создаёт приватные копии
    long long sum = 0;

    // директива OpenMP:
    // - создаёт пул потоков (если ещё не создан)
    // - распределяет диапазоны итераций for по потокам
    //   пример: при 4 потоках каждый обрабатывает свой блок
    //
    // reduction(+:sum):
    // - для каждого потока создаётся локальная копия sum_local
    // - sum_local инициализируется нулём
    // - в теле цикла запись идёт в sum_local, а НЕ в общую переменную
    // - после завершения всех потоков выполняется reduction:
    //       суммирование sum_local[0] + sum_local[1] + ...
    //   и результат записывается в sum (общая переменная)
    //
    // Важно: такое поведение предотвращает гонки при записи sum
    //        без reduction была бы data race и неопределённое поведение
    #pragma omp parallel for reduction(+:sum)
    for (long long i = 0; i < (long long)N; i++) {

        // локальный поток читает arr[i] из области heap
        // чтения конкурентные, но это безопасно (нет модификаций)
        //
        // запись sum += arr[i] идёт в sum_local, уникальный для потока
        sum += arr[i];
    }

    // reduction завершён, sum содержит суммарное значение
    return static_cast<double>(sum) / N;
}

int main() {

    // число элементов массива
    // объём = 5 млн * sizeof(int) = ~20 МБ в куче
    size_t N = 5'000'000;

    //---------------------------------------------------------
    // Динамическое выделение массива в куче (heap)
    //---------------------------------------------------------

    // new вызывает оператор, который внутри вызывает malloc (или аналог)
    // выделяется непрерывный блок памяти N * sizeof(int)
    // в случае ошибки new генерирует исключение std::bad_alloc
    int* arr = new int[N];

    //---------------------------------------------------------
    // Инициализация генератора случайных чисел
    //---------------------------------------------------------

    // std::random_device{} генерирует seed
    // mt19937 хранит внутреннее состояние 624*32-бит слова (~2.5 KB),
    // размещаемое в стеке внутри объекта gen
    std::mt19937 gen(std::random_device{}());

    // равномерное распределение int в диапазоне [1;100]
    std::uniform_int_distribution<int> dist(1,100);

    //---------------------------------------------------------
    // Заполнение массива случайными значениями
    //---------------------------------------------------------
    // итерация идёт последовательно
    for(size_t i=0;i<N;i++){
        arr[i] = dist(gen);
        // dist генерирует число,
        // arr[i] пишется в heap, запись безопасна, так как один поток
    }

    //---------------------------------------------------------
    // Измерение времени последовательного алгоритма
    //---------------------------------------------------------

    auto t1 = std::chrono::high_resolution_clock::now();
    double avg_seq = sequential_avg(arr,N);
    auto t2 = std::chrono::high_resolution_clock::now();

    auto seq_time =
        std::chrono::duration_cast<std::chrono::milliseconds>(t2-t1).count();
    // duration_cast конвертирует внутреннюю единицу измерения clocks → миллисекунды
    // time_point разность даёт duration

    //---------------------------------------------------------
    // Измерение времени параллельного алгоритма
    //---------------------------------------------------------

    auto t3 = std::chrono::high_resolution_clock::now();
    double avg_par = parallel_avg(arr,N);
    auto t4 = std::chrono::high_resolution_clock::now();

    auto par_time =
        std::chrono::duration_cast<std::chrono::milliseconds>(t4-t3).count();

    //---------------------------------------------------------
    // Вывод результатов
    //---------------------------------------------------------

    std::cout << "Sequential average = " << avg_seq << "\n";
    std::cout << "Parallel average   = " << avg_par << "\n";
    std::cout << "Seq time = " << seq_time << " ms\n";
    std::cout << "Par time = " << par_time << " ms\n";

    //---------------------------------------------------------
    // Освобождение памяти
    //---------------------------------------------------------

    delete[] arr;
    // delete[] вызывает деструктор для int — тривиальный
    // освобождает блок heap через runtime

    return 0;
    // стек очищается, объекты времени уничтожаются
    // runtime завершает поток, ОС освобождает оставшиеся ресурсы
}